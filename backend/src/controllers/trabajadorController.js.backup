const pool = require('../database/db'); // AÑADE ESTA LÍNEA
const Reserva = require('../models/Reserva');
const Servicio = require('../models/Servicio');
const Trabajador = require('../models/Trabajador');
const CalendarioUtils = require('../utils/calendarioUtils');

// Función helper para obtener el ID del trabajador según el tipo de usuario
const obtenerTrabajadorId = (req) => {
  console.log('👤 Usuario en request:', {
    id: req.usuario?.id,
    rol: req.usuario?.rol,
    trabajadorId: req.usuario?.trabajadorId
  });

  if (req.usuario.rol === 'trabajador') {
    return req.usuario.id;
  } else if (req.usuario.rol === 'administrador' && req.usuario.trabajadorId) {
    return req.usuario.trabajadorId;
  }
  return null;
};

// Función para verificar si un trabajador puede realizar un servicio
const verificarEspecialidad = async (trabajadorId, servicioId) => {
  try {
    console.log(`🔍 [ESPECIALIDAD] Verificando trabajador ${trabajadorId} para servicio ${servicioId}`);

    const trabajador = await Trabajador.obtenerPerfil(trabajadorId);
    const servicio = await Servicio.buscarPorId(servicioId);

    if (!trabajador) {
      console.log('❌ [ESPECIALIDAD] Trabajador no encontrado');
      return false;
    }

    if (!servicio) {
      console.log('❌ [ESPECIALIDAD] Servicio no encontrado');
      return false;
    }

    const puedeRealizar = CalendarioUtils.puedeRealizarServicio(trabajador, servicio);
    console.log(`🎯 [ESPECIALIDAD] Resultado: ${puedeRealizar ? '✅ PUEDE' : '❌ NO PUEDE'} - ${trabajador.nombre} para ${servicio.nombre}`);

    return puedeRealizar;
  } catch (error) {
    console.error('Error en verificarEspecialidad:', error);
    return false;
  }
};

const trabajadorController = {
  // 1. Obtener MIS reservas asignadas específicamente a mí
  obtenerMisReservas: async (req, res) => {
    try {
      const trabajador_id = obtenerTrabajadorId(req);

      if (!trabajador_id) {
        return res.status(403).json({ error: 'No estás registrado como trabajador' });
      }

      console.log(`🔍 [CONTROLADOR] Buscando reservas EXCLUSIVAS para trabajador_id: ${trabajador_id}`);

      // CONSULTA MEJORADA - Traer TODOS los datos necesarios
      const [rows] = await pool.execute(`
        SELECT 
          r.*,
          u_cliente.nombre as cliente_nombre,
          u_cliente.apellidos as cliente_apellidos, 
          u_cliente.telefono as cliente_telefono,
          s.nombre as servicio_nombre,
          s.precio as servicio_precio,
          s.duracion as servicio_duracion,
          s.categoria as servicio_categoria,
          s.descripcion as servicio_descripcion,
          u_trabajador.nombre as trabajador_nombre,
          u_trabajador.apellidos as trabajador_apellidos,
          u_trabajador.email as trabajador_email,
          t.especialidades as trabajador_especialidades
        FROM reservas r
        JOIN usuarios u_cliente ON r.cliente_id = u_cliente.id
        JOIN servicios s ON r.servicio_id = s.id
        LEFT JOIN trabajadores t ON r.trabajador_id = t.id
        LEFT JOIN usuarios u_trabajador ON t.usuario_id = u_trabajador.id
        WHERE r.trabajador_id = ?
        ORDER BY r.fecha_reserva DESC, r.hora_inicio DESC
      `, [trabajador_id]);

      console.log(`📊 [CONTROLADOR] Encontradas ${rows.length} reservas para trabajador ${trabajador_id}`);

      // Formatear respuesta de manera consistente
      const reservasFormateadas = rows.map(r => {
        // Manejar especialidades (puede ser string JSON o array)
        let especialidades = [];
        try {
          if (r.trabajador_especialidades) {
            especialidades = typeof r.trabajador_especialidades === 'string'
              ? JSON.parse(r.trabajador_especialidades)
              : r.trabajador_especialidades;
          }
        } catch (error) {
          console.warn('Error parseando especialidades:', error);
          especialidades = [];
        }

        return {
          // Datos básicos de la reserva
          id: r.id,
          cliente_id: r.cliente_id,
          servicio_id: r.servicio_id,
          trabajador_id: r.trabajador_id,
          fecha_reserva: r.fecha_reserva,
          hora_inicio: r.hora_inicio,
          duracion: r.duracion,
          estado: r.estado,
          notas: r.notas,
          precio: r.servicio_precio,

          // Campos planos para compatibilidad (formato calendario general)
          cliente_nombre: r.cliente_nombre,
          cliente_apellidos: r.cliente_apellidos,
          servicio_nombre: r.servicio_nombre,
          servicio_precio: r.servicio_precio,
          servicio_duracion: r.servicio_duracion,
          servicio_categoria: r.servicio_categoria,
          trabajador_nombre: r.trabajador_nombre,
          trabajador_apellidos: r.trabajador_apellidos,

          // Objetos anidados (formato trabajadores)
          cliente: {
            id: r.cliente_id,
            nombre: r.cliente_nombre,
            apellidos: r.cliente_apellidos,
            telefono: r.cliente_telefono
          },
          servicio: {
            id: r.servicio_id,
            nombre: r.servicio_nombre,
            precio: r.servicio_precio,
            duracion: r.servicio_duracion,
            categoria: r.servicio_categoria,
            descripcion: r.servicio_descripcion
          },
          trabajador: {
            id: r.trabajador_id,
            nombre: r.trabajador_nombre,
            apellidos: r.trabajador_apellidos,
            email: r.trabajador_email,
            especialidades: especialidades
          }
        };
      });

      res.json({
        total: reservasFormateadas.length,
        reservas: reservasFormateadas
      });
    } catch (error) {
      console.error('❌ Error en obtenerMisReservas:', error);
      res.status(500).json({
        error: 'Error interno del servidor',
        detalle: error.message
      });
    }
  },

  // 2. Obtener reservas DISPONIBLES (sin trabajador asignado)
  obtenerReservasDisponibles: async (req, res) => {
    try {
      const trabajador_id = obtenerTrabajadorId(req);

      if (!trabajador_id) {
        return res.status(403).json({ error: 'No estás registrado como trabajador' });
      }

      console.log(`🔍 [DISPONIBLES] Buscando reservas disponibles para trabajador: ${trabajador_id}`);

      // Consulta directa para reservas sin trabajador asignado
      const [rows] = await pool.execute(`
        SELECT 
          r.*,
          u_cliente.nombre as cliente_nombre,
          u_cliente.apellidos as cliente_apellidos,
          s.nombre as servicio_nombre,
          s.categoria as servicio_categoria,
          s.precio as servicio_precio,
          s.duracion as servicio_duracion
        FROM reservas r
        JOIN usuarios u_cliente ON r.cliente_id = u_cliente.id
        JOIN servicios s ON r.servicio_id = s.id
        WHERE r.trabajador_id IS NULL 
        AND r.estado = 'pendiente'
        ORDER BY r.fecha_reserva, r.hora_inicio
      `);

      console.log(`📊 [DISPONIBLES] Encontradas ${rows.length} reservas disponibles`);

      // Filtrar por especialidad
      const trabajador = await Trabajador.obtenerPerfil(trabajador_id);
      const reservasFiltradas = [];

      for (const reserva of rows) {
        const puedeRealizar = await verificarEspecialidad(trabajador_id, reserva.servicio_id);
        if (puedeRealizar) {
          reservasFiltradas.push({
            id: reserva.id,
            fecha_reserva: reserva.fecha_reserva,
            hora_inicio: reserva.hora_inicio,
            duracion: reserva.duracion,
            servicio: {
              id: reserva.servicio_id,
              nombre: reserva.servicio_nombre,
              categoria: reserva.servicio_categoria,
              precio: reserva.servicio_precio,
              duracion: reserva.servicio_duracion
            },
            cliente: {
              nombre: reserva.cliente_nombre,
              apellidos: reserva.cliente_apellidos
            },
            notas: reserva.notas,
            especialidad_requerida: reserva.servicio_categoria
          });
        }
      }

      console.log(`🎯 [DISPONIBLES] ${reservasFiltradas.length} reservas coinciden con especialidad`);

      res.json({
        total: reservasFiltradas.length,
        reservas: reservasFiltradas
      });
    } catch (error) {
      console.error('Error en obtenerReservasDisponibles:', error);
      res.status(500).json({
        error: 'Error interno del servidor',
        detalle: error.message
      });
    }
  },

  // 3. Tomar una reserva disponible
  tomarReserva: async (req, res) => {
    try {
      const { id } = req.params;
      const trabajador_id = obtenerTrabajadorId(req);

      if (!trabajador_id) {
        return res.status(403).json({ error: 'No estás registrado como trabajador' });
      }

      console.log(`🔍 [TOMAR] Trabajador ${trabajador_id} intentando tomar reserva ${id}`);

      // Verificar que la reserva existe y está disponible
      const [reservas] = await pool.execute(
        'SELECT * FROM reservas WHERE id = ? AND trabajador_id IS NULL AND estado = "pendiente"',
        [id]
      );

      if (reservas.length === 0) {
        return res.status(404).json({ error: 'Reserva no encontrada o no disponible' });
      }

      const reserva = reservas[0];

      // Verificar especialidad
      const puedeRealizar = await verificarEspecialidad(trabajador_id, reserva.servicio_id);
      if (!puedeRealizar) {
        return res.status(400).json({
          error: 'No puedes tomar esta reserva - No tienes la especialidad requerida'
        });
      }

      // Verificar disponibilidad del trabajador
      const [conflictos] = await pool.execute(
        `SELECT id FROM reservas 
         WHERE trabajador_id = ? 
         AND fecha_reserva = ? 
         AND (
           (hora_inicio <= ? AND DATE_ADD(hora_inicio, INTERVAL duracion MINUTE) > ?)
           OR (hora_inicio < DATE_ADD(?, INTERVAL ? MINUTE) AND DATE_ADD(hora_inicio, INTERVAL duracion MINUTE) >= DATE_ADD(?, INTERVAL ? MINUTE))
         )`,
        [
          trabajador_id,
          reserva.fecha_reserva,
          reserva.hora_inicio,
          reserva.hora_inicio,
          reserva.hora_inicio,
          reserva.duracion,
          reserva.hora_inicio,
          reserva.duracion
        ]
      );

      if (conflictos.length > 0) {
        return res.status(400).json({
          error: 'No tienes disponibilidad en este horario'
        });
      }

      // Asignar reserva al trabajador
      await pool.execute(
        'UPDATE reservas SET trabajador_id = ?, estado = "asignada" WHERE id = ?',
        [trabajador_id, id]
      );

      // Obtener la reserva actualizada
      const [reservaActualizada] = await pool.execute(
        `SELECT r.*, 
          u_cliente.nombre as cliente_nombre, u_cliente.apellidos as cliente_apellidos,
          s.nombre as servicio_nombre, s.precio as servicio_precio
         FROM reservas r
         JOIN usuarios u_cliente ON r.cliente_id = u_cliente.id
         JOIN servicios s ON r.servicio_id = s.id
         WHERE r.id = ?`,
        [id]
      );

      res.json({
        mensaje: 'Reserva tomada exitosamente',
        reserva: reservaActualizada[0]
      });
    } catch (error) {
      console.error('Error en tomarReserva:', error);
      res.status(500).json({
        error: 'Error interno del servidor',
        detalle: error.message
      });
    }
  },

  // 4. Aceptar reserva
  aceptarReserva: async (req, res) => {
    try {
      const { id } = req.params;
      const trabajador_id = obtenerTrabajadorId(req);

      if (!trabajador_id) {
        return res.status(403).json({ error: 'No estás registrado como trabajador' });
      }

      // Verificar que la reserva es del trabajador
      const [reservas] = await pool.execute(
        'SELECT * FROM reservas WHERE id = ? AND trabajador_id = ?',
        [id, trabajador_id]
      );

      if (reservas.length === 0) {
        return res.status(404).json({ error: 'Reserva no encontrada o no tienes permisos' });
      }

      const reserva = reservas[0];

      if (reserva.estado !== 'pendiente' && reserva.estado !== 'asignada') {
        return res.status(400).json({ error: 'La reserva no puede ser aceptada en su estado actual' });
      }

      // Cambiar estado a confirmada
      await pool.execute(
        'UPDATE reservas SET estado = "confirmada" WHERE id = ?',
        [id]
      );

      res.json({
        mensaje: 'Reserva aceptada exitosamente',
        reserva_id: id
      });
    } catch (error) {
      console.error('Error en aceptarReserva:', error);
      res.status(500).json({
        error: 'Error interno del servidor',
        detalle: error.message
      });
    }
  },

  // 5. Rechazar reserva
  rechazarReserva: async (req, res) => {
    try {
      const { id } = req.params;
      const { motivo } = req.body;
      const trabajador_id = obtenerTrabajadorId(req);

      if (!trabajador_id) {
        return res.status(403).json({ error: 'No estás registrado como trabajador' });
      }

      // Verificar que la reserva es del trabajador
      const [reservas] = await pool.execute(
        'SELECT * FROM reservas WHERE id = ? AND trabajador_id = ?',
        [id, trabajador_id]
      );

      if (reservas.length === 0) {
        return res.status(404).json({ error: 'Reserva no encontrada o no tienes permisos' });
      }

      const reserva = reservas[0];

      if (reserva.estado !== 'pendiente' && reserva.estado !== 'asignada') {
        return res.status(400).json({ error: 'La reserva no puede ser rechazada en su estado actual' });
      }

      let resultado;

      // Si es una reserva específica, cancelar completamente
      if (reserva.notas && reserva.notas.includes('selección específica')) {
        await pool.execute(
          'UPDATE reservas SET estado = "cancelada" WHERE id = ?',
          [id]
        );
        resultado = { liberada: false };
      } else {
        // Reserva tomada - liberar para otros
        await pool.execute(
          'UPDATE reservas SET trabajador_id = NULL, estado = "pendiente" WHERE id = ?',
          [id]
        );
        resultado = { liberada: true };
      }

      res.json({
        mensaje: 'Reserva rechazada exitosamente',
        reserva_id: id,
        ...resultado
      });
    } catch (error) {
      console.error('Error en rechazarReserva:', error);
      res.status(500).json({
        error: 'Error interno del servidor',
        detalle: error.message
      });
    }
  }
};

module.exports = trabajadorController;